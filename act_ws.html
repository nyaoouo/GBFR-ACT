<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Remote</title>
    <script>
        const cdn_loader = (async (data) => {
            for (const {key, type, choices} of data) await new Promise((resolve, reject) => {
                const cdn_like = JSON.parse(localStorage.getItem('cdnLike') || '{}');
                choices.sort((a, b) => cdn_like[key] === a ? -1 : cdn_like[key] === b ? 1 : 0);
                (function try_one_by_one(idx) {
                    if (idx >= choices.length) return reject(`all cdn of ${key} is not available`);
                    let el;
                    new Promise((resolve_, reject_) => {
                        if (type === 'css') {
                            el = document.createElement('link');
                            el.rel = 'stylesheet';
                            el.href = choices[idx];
                        } else {
                            el = document.createElement('script');
                            el.src = choices[idx];
                        }
                        el.onerror = reject_
                        el.onload = resolve_
                        document.head.appendChild(el);
                    }).then(() => {
                        console.log(`cdn of ${key} is loaded from ${choices[idx]}`);
                        cdn_like[key] = choices[idx];
                        localStorage.setItem('cdnLike', JSON.stringify(cdn_like));
                        resolve();
                    }).catch(e => {
                        console.error(`cdn of ${key} is not loaded from ${choices[idx]}`, e);
                        el.remove();
                        try_one_by_one(idx + 1);
                    });
                })(0);
            })
        })([{
            key: 'css/element-plus', type: 'css',
            choices: [
                "https://unpkg.com/element-plus/dist/index.css",
                "https://s4.zstatic.net/npm/element-plus/dist/index.css",
            ]
        },
            {
                key: 'css/bootstrap', type: 'css',
                choices: [
                    "https://cdn.jsdelivr.net/npm/bootstrap@latest/dist/css/bootstrap.min.css",
                    "https://s4.zstatic.net/npm/bootstrap@latest/dist/css/bootstrap.min.css",
                ]
            },
            {
                key: 'js/chart.js', type: 'js',
                choices: [
                    "https://cdn.jsdelivr.net/npm/chart.js",
                    "https://s4.zstatic.net/npm/chart.js",
                ]
            },
            {
                key: 'js/bootstrap', type: 'js',
                choices: [
                    "https://cdn.jsdelivr.net/npm/bootstrap@latest/dist/js/bootstrap.bundle.min.js",
                    "https://s4.zstatic.net/npm/bootstrap@latest/dist/js/bootstrap.bundle.min.js",
                ]
            },
            {
                key: 'js/vue', type: 'js',
                choices: [
                    "https://unpkg.com/vue@3/dist/vue.global.js",
                    "https://s4.zstatic.net/npm/vue@3/dist/vue.global.js",
                ]
            },
            {
                key: 'js/element-plus', type: 'js',
                choices: [
                    "https://unpkg.com/element-plus",
                    "https://s4.zstatic.net/npm/element-plus@latest/dist/index.full.min.js",
                ]
            },
            {
                key: 'js/element-plus-icons-vue', type: 'js',
                choices: [
                    "https://unpkg.com/@element-plus/icons-vue",
                    "https://s4.zstatic.net/npm/@element-plus/icons-vue",
                ]
            },
            {
                key: 'js/vue-i18n', type: 'js',
                choices: [
                    "https://unpkg.com/vue-i18n@9",
                    "https://s4.zstatic.net/npm/vue-i18n@9",
                ]
            },
        ])
    </script>
</head>
<style>
    [v-cloak] {
        display: none;
    }

    body {
        font-family: -apple-system,
        'Nimbus Roman No9 L',
        'PingFang SC Regular',
        'Hiragino Sans GB',
        'Microsoft Yahei',
        'WenQuanYi Micro Hei',
        'ST Heiti', sans-serif
    }

    ::-webkit-scrollbar {
        width: 5px;
        height: 5px;
        background-color: #F5F5F5;
    }

    ::-webkit-scrollbar-track {
        -webkit-box-shadow: inset 0 0 6px rgb(93, 93, 93);
        border-radius: 10px;
        background-color: #F5F5F5;
    }

    ::-webkit-scrollbar-thumb {
        border-radius: 10px;
        -webkit-box-shadow: inset 0 0 6px rgba(166, 166, 166, 0.3);
        background-color: rgb(234, 234, 234);
    }

    .main-0 {
        display: table;
        position: absolute;
        height: 100%;
        width: 100%;
    }

    .main-1 {
        display: table-cell;
        vertical-align: middle;
    }

    .main-2 {
        min-width: 80%;
        width: 1000px;
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
    }
</style>
<body>
<div id="app" class="main-0">
    <div class="main-1" v-cloak>
        <div class="main-2" v-if="0">
            resource is loading, please wait...
        </div>
        <div class="main-2 shadow rounded p-3" v-cloak>
            <div v-if="!is_socket_connected" class="p-3">
                <el-alert title="socket is not connect, check inject status" type="error" effect="dark" :closable="false"></el-alert>
            </div>
            <div style="position: absolute;right: 0;bottom: 0;padding: 2rem;z-index: 99">
                <el-popover
                        trigger="click" :width="300"
                        popper-style="box-shadow: rgb(14 18 22 / 35%) 0px 10px 38px -10px, rgb(14 18 22 / 20%) 0px 10px 20px -15px; padding: 20px;"
                >
                    <template #reference>
                        <el-icon>
                            <Operation/>
                        </el-icon>
                    </template>
                    <template #default>
                        <el-form
                                label-position="right"
                                label-width="150px"
                        >
                            <el-form-item :label="$t('ui.chart_main')">
                                <el-select v-model="cfg.chart" placeholder="Select">
                                    <el-option :label="`${$t('ui.chart')}-${$t('ui.dps_in_minute')}`" value="dps_min"></el-option>
                                    <el-option :label="`${$t('ui.chart')}-${$t('ui.damage')}`" value="dmg"></el-option>
                                </el-select>
                            </el-form-item>
                            <el-form-item :label="$t('ui.language')">
                                <el-select v-model="$i18n.locale" placeholder="Select">
                                    <el-option
                                            v-for="k in $i18n.availableLocales"
                                            :key="k"
                                            :label="$t('locale_name',k)"
                                            :value="k"
                                    />
                                </el-select>
                            </el-form-item>
                            <el-form-item :label="$t('ui.keep_record')">
                                <el-switch v-model="cfg.keep_record"/>
                            </el-form-item>
                        </el-form>
                    </template>
                </el-popover>
            </div>

            <el-dialog v-model="actor_dialog.visible" :title="actor_dialog.actor?actor_dialog.actor.display_name:''" @close="set_actor_dialog()" width="80%" top="5vh">
                <el-tabs
                        v-model="actor_dialog.page"
                        type="card"
                        v-if="actor_dialog.actor"
                >
                    <el-tab-pane :label="$t('ui.targets')" name="targets">
                        <el-table :data="actor_dialog.actor.targets" style="width: 100%" :default-sort="{ prop: 'damage', order: 'descending' }">
                            <el-table-column prop="name" :label="$t('ui.name')">
                            </el-table-column>
                            <el-table-column prop="damage" :label="$t('ui.damage')" sortable>
                                <template #default="scope">
                                    <span>{{numberWithComma(scope.row.damage)}}</span>
                                </template>
                            </el-table-column>
                        </el-table>
                    </el-tab-pane>
                    <el-tab-pane :label="$t('ui.actions')" name="actions">
                        <div :style="{display:actor_dialog.action_chart.selected?'block':'none'}">
                            <canvas :ref="el => { actor_dialog.action_chart.canvas = el }" :height="screen.height*0.5"></canvas>
                        </div>
                        <el-table :data="actor_dialog.actor.actions" style="width: 100%" :height="actor_dialog.action_chart.selected?screen.height*0.3:screen.height*0.5" :default-sort="{ prop: 'damage', order: 'descending' }">
                            <el-table-column prop="display_name">
                                <template #header>
                                    <span>{{$t('ui.name')}}</span>
                                    <el-popover v-if="actor_dialog.actor.action_desc" placement="right" :content="actor_dialog.actor.action_desc">
                                        <template #reference>
                                            <el-link class="mx-1">
                                                <el-icon>
                                                    <Star/>
                                                </el-icon>
                                            </el-link>
                                        </template>
                                    </el-popover>
                                </template>
                                <template #default="scope">
                                    <el-link @click="actor_dialog.action_chart.selected=scope.row">{{scope.row.display_name}}</el-link>
                                    <el-popover v-if="scope.row.display_desc" placement="right" :content="scope.row.display_desc">
                                        <template #reference>
                                            <el-link class="mx-1">
                                                <el-icon>
                                                    <Star/>
                                                </el-icon>
                                            </el-link>
                                        </template>
                                    </el-popover>
                                </template>
                            </el-table-column>
                            <el-table-column prop="hit" :label="$t('ui.hit')" sortable>
                                <template #default="scope">
                                    <span>{{numberWithComma(scope.row.hit)}} ({{(scope.row.hit/actor_dialog.actor.hit*100).toFixed(1)}}%)</span>
                                </template>
                            </el-table-column>
                            <el-table-column prop="damage" :label="$t('ui.damage')" sortable>
                                <template #default="scope">
                                    <span>{{numberWithComma(scope.row.damage)}} ({{scope.row.damage?(scope.row.damage/actor_dialog.actor.damage*100).toFixed(1):0}}%)</span>
                                </template>
                            </el-table-column>
                            <el-table-column prop="min" :label="$t('ui.min')" sortable>
                                <template #default="scope">
                                    <span>{{numberWithComma(scope.row.min)}}</span>
                                </template>
                            </el-table-column>
                            <el-table-column prop="max" :label="$t('ui.max')" sortable>
                                <template #default="scope">
                                    <span>{{numberWithComma(scope.row.max)}}</span>
                                </template>
                            </el-table-column>
                            <el-table-column :label="$t('ui.damage_avg')">
                                <template #default="scope">
                                    <span v-if="scope.row.hit > 0">{{numberWithComma(Math.floor(scope.row.damage / scope.row.hit))}}</span>
                                </template>
                            </el-table-column>
                        </el-table>
                    </el-tab-pane>
                </el-tabs>
            </el-dialog>

            <el-tabs
                    v-model="view_record_value"
                    type="card"
                    closable @tab-remove="remove_record"
            >
                <el-tab-pane
                        v-for="item in records" :key="item.name" :label="item.last_record_at?`${item.name} [${fmtTime(item.last_record_at-item.time_ms)}]`:item.name" :name="item.name"
                >
                    <el-table :data="item.actors" style="width: 100%" :default-sort="{ prop: 'dps', order: 'descending' }">
                        <el-table-column prop="name">
                            <template #header>
                                <el-button circle @click="export_log(item)">
                                    <el-icon>
                                        <Download/>
                                    </el-icon>
                                </el-button>
                            </template>
                            <template #default="scope">
                                <span>
                                    <el-icon :style="{'color':scope.row.color}"><Avatar/></el-icon> {{scope.row.display_name}}
                                </span>
                            </template>
                        </el-table-column>
                        <el-table-column prop="damage" :label="$t('ui.damage')" sortable>
                            <template #default="scope">
                                <span>{{numberWithComma(scope.row.damage)}} ({{scope.row.damage?(scope.row.damage/item.damage*100).toFixed(1):0}}%)</span>
                            </template>
                        </el-table-column>
                        <el-table-column prop="damage_in_minute" :label="$t('ui.damage_in_minute')" sortable>
                            <template #default="scope">
                                <span>{{numberWithComma(scope.row.damage_in_minute)}}</span>
                            </template>
                        </el-table-column>
                        <el-table-column prop="dps" :label="$t('ui.dps')" sortable>
                            <template #default="scope">
                                <span>{{numberWithComma(scope.row.dps)}}</span>
                            </template>
                        </el-table-column>
                        <el-table-column prop="dps_in_minute" :label="$t('ui.dps_in_minute')" sortable>
                            <template #default="scope">
                                <span>{{numberWithComma(scope.row.dps_in_minute)}}</span>
                            </template>
                        </el-table-column>
                        <el-table-column :label="$t('ui.detail')">
                            <template #default="scope">
                                <el-button @click="set_actor_dialog(scope.row)" type="text" size="small">detail</el-button>
                            </template>
                        </el-table-column>
                    </el-table>
                    <div :style="{display:item.show_chart?'block':'none'}">
                        <canvas :style="{display:cfg.chart=='dps_min'?'block':'none'}" :ref="el => { item.dps_canvas = el }" height="500"></canvas>
                        <canvas :style="{display:cfg.chart=='dmg'?'block':'none'}" :ref="el => { item.dmg_canvas = el }" height="500"></canvas>
                    </div>
                </el-tab-pane>
            </el-tabs>
        </div>
    </div>
</div>
</body>
<script src="./act_ws_texts.js"></script>
<script>
    const _with_time = f => (...args) => {
        const now = new Date();
        f(`[${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}]`, ...args);
    }
    const log_cond = {
        evt: 0,
        render: 0,
        damage: 0,
    }
    const log = _with_time(console.log);
    const err = _with_time(console.error);
    const flag_offs = (val) => Array.from(Array(val.toString(2).length).keys())
            .filter(off => val & (1 << off));

    let socket = null;

    function numberToHexStringWithZFill(number, minLength) {
        let hexString = number.toString(16);
        while (hexString.length < minLength) {
            hexString = '0' + hexString;
        }
        return hexString;
    }

    const numberWithComma = new Intl.NumberFormat('en-EN', {maximumFractionDigits: 2}).format;

    const fmtTime = (ms) => {
        if (ms < 1000) return ms + "ms";
        const sec = Math.floor(ms / 1000);
        if (sec < 60) return sec + "s";
        const min = Math.floor(sec / 60);
        return `${min}m${sec % 60}s`;
    }

    class ActionDamageChart {
        constructor(canvas, max_display = 100) {
            this.datas = {
                datasets: [{
                    label: '',
                    data: [],
                    borderColor: '#11ff11',
                    backgroundColor: '#11ff11',
                    fill: false,
                }]
            };
            this.chart = new Chart(canvas.getContext('2d'), {
                type: 'scatter',
                data: this.datas,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            position: 'bottom',
                        },
                        y: {
                            position: 'left',
                        }
                    },
                    animation: {
                        y: {
                            duration: 0
                        },
                        x: {
                            duration: 0
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (ctx) {
                                    // console.log(ctx);
                                    return ctx.parsed.y;
                                }
                            }
                        }
                    },

                }
            });
            this.max_display = max_display;
            this.current = null;
        }

        set({color = undefined, datas = undefined, label = undefined}) {
            const dataset = this.datas.datasets[0];
            if (color) {
                dataset.borderColor = color;
                dataset.backgroundColor = color;
            }
            if (label) dataset.label = label;
            if (datas) {
                dataset.data = (
                        this.max_display && datas.length > this.max_display ?
                                datas.slice(datas.length - this.max_display) :
                                datas
                ).map(({x, y}) => ({x, y}));
            }
            return dataset;
        }

        put({x, y}) {
            const dataset = this.datas.datasets[0];
            dataset.data.push({x, y});
            if (this.max_display && dataset.data.length > this.max_display) {
                dataset.data.shift();
            }
            this.chart.update();
        }

        clear() {
            const dataset = this.datas.datasets[0];
            dataset.data = [];
            dataset.label = '';
            this.chart.update();
        }

        destroy() {
            this.chart.destroy();
        }

        static instance = null;
    }


    cdn_loader.then(() => {
        const i18n = VueI18n.createI18n(i18nCfg);

        const evt_action_id = ({flags, action_id}) => {
            if (flags & (1 << 15)) return -3;
            return action_id;
        }

        const actor_name = (actor_id) => {
            const name_key = numberToHexStringWithZFill(actor_id, 8);
            return i18n.global.te(`game.actors.${name_key}`) ? i18n.global.t(`game.actors.${name_key}`) : name_key;
        }

        const action_name = (actor_id, action_id) => {
            const key = `game.actions.${numberToHexStringWithZFill(actor_id, 8)}.${action_id}`;
            return i18n.global.te(key) ? i18n.global.t(key) : `${action_id}`;
        }

        class RecordEx {
            // static chart_period = 10 * 60;
            static chart_period = 0;

            constructor(key) {
                if (RecordEx.instances[key]) throw new Error(`record ${key} already exists`);
                this.key = key;
                this.dps_chart = null;
                this.dmg_chart = null;
                this.dps_chart_data = {datasets: []};
                this.dmg_chart_data = {datasets: []};
                this.events = [];
                RecordEx.instances[key] = this;
            }

            new_chart_actor(name, color) {
                this.dps_chart_data.datasets.push({label: name, data: [], borderColor: color, backgroundColor: color, fill: false});
                this.dmg_chart_data.datasets.push({label: name, data: [], borderColor: color, backgroundColor: color, fill: false});
            }

            update_chart(time_sec, record) {
                if (RecordEx.chart_period > 0) {
                    const min_time = time_sec - RecordEx.chart_period;
                    for (const dataset of this.dps_chart_data.datasets) {
                        const cutoff_idx = dataset.data.findIndex(d => d.x > min_time);
                        if (cutoff_idx >= 0) dataset.data = dataset.data.slice(cutoff_idx);
                    }
                    for (const dataset of this.dmg_chart_data.datasets) {
                        const cutoff_idx = dataset.data.findIndex(d => d.x > min_time);
                        if (cutoff_idx >= 0) dataset.data = dataset.data.slice(cutoff_idx);
                    }
                }
                for (const {display_name, damage, dps} of record.actors) {
                    const dps_dataset = this.dps_chart_data.datasets.find(ds => ds.label === display_name);
                    if (dps_dataset) dps_dataset.data.push({x: time_sec, y: dps});
                    const dmg_dataset = this.dmg_chart_data.datasets.find(ds => ds.label === display_name);
                    if (dmg_dataset) dmg_dataset.data.push({x: time_sec, y: damage});
                }
            }

            redraw_chart(record) {
                this.get_dmg_chart(record.dmg_canvas)?.update();
                this.get_dps_chart(record.dps_canvas)?.update();
            }

            get_dps_chart(canvas) {
                if (!this.dps_chart && canvas) this.dps_chart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: this.dps_chart_data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {x: {type: 'linear', position: 'bottom',}, y: {position: 'left',}},
                        animation: {y: {duration: 0}, x: {duration: 0}},
                        elements: {point: {radius: 0}}
                    }
                });
                return this.dps_chart;
            }

            get_dmg_chart(canvas) {
                if (!this.dmg_chart && canvas) this.dmg_chart = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: this.dmg_chart_data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {x: {type: 'linear', position: 'bottom',}, y: {position: 'left',}},
                        animation: {y: {duration: 0}, x: {duration: 0}},
                        elements: {point: {radius: 0}}
                    }
                });
                return this.dmg_chart;
            }

            destroy() {
                if (this.dps_chart) {
                    this.dps_chart.destroy();
                    this.dps_chart = null;
                }
                if (this.dmg_chart) {
                    this.dmg_chart.destroy();
                    this.dmg_chart = null;
                }
                delete RecordEx.instances[this.name];
            }

            static instances = {};

            static get_instance(key) {
                return RecordEx.instances[key] || new RecordEx(key);
            }

            static destroy_instance(key) {
                const record = RecordEx.instances[key];
                if (record) record.destroy();
            }
        }

        class ActorTarget {
            constructor(idx, id, party_idx) {
                this.idx = idx;
                this.name = party_idx === -1 ? `${actor_name(id)}#${idx}` : `[${party_idx}]${actor_name(id)}#${idx}`;
                this.damage = 0;
            }
        }

        class ActorAction {
            static  common_actions = (() => {
                const res = {};
                res[-1] = 'game.actions.common.link';
                res[-2] = 'game.actions.common.lb';
                res[-3] = 'game.actions.common.bonus';
                res[-0x100] = 'game.actions.common.dot';
                res[5000] = 'game.actions.common.ether_round';
                res[5010] = 'game.actions.common.charged_shot';
                return res;
            })()

            constructor(actor_key, action_id) {
                this.id = action_id;
                const key = ActorAction.common_actions[action_id] || `game.actions.${actor_key}.${action_id}`;
                this.display_name = i18n.global.te(key) ? i18n.global.t(key) : `${action_id}`;
                this.display_desc = i18n.global.te(`${key}.desc`) ? i18n.global.t(`${key}.desc`) : '';
                this.hit = 0;
                this.damage = 0;
                this.min = -1;
                this.max = -1;
            }
        }

        class Actor {
            static colors = [
                '#55ff55',
                '#ff5555',
                '#5555ff',
                '#ffff55',
                '#ff55ff',
                '#55ffff',
            ]

            constructor(record_key, idx, id, party_idx) {
                this.record_key = record_key;
                this.idx = idx;
                this.party_idx = party_idx;
                this.name_key = numberToHexStringWithZFill(id, 8);
                this.display_name = `[${party_idx}]${i18n.global.t(`game.actors.${this.name_key}`)}#${idx}`;
                this.color = Actor.colors[party_idx];
                this.damage = 0;
                this.damage_in_minute = 0;
                this.dps = 0;
                this.dps_in_minute = 0;
                this.targets = [];
                this.actions = [];
                this.action_desc = (() => {
                    const key = `game.actions.${this.name_key}.desc`;
                    const res = i18n.global.t(key);
                    return res === key ? "" : res;
                })();
                this.hit = 0;
            }

            get_target(target_idx, target_id, target_party_idx) {
                const res = this.targets.find(v => v.idx === target_idx);
                if (res) return res;
                const new_res = Vue.reactive(new ActorTarget(target_idx, target_id, target_party_idx));
                this.targets.push(new_res);
                return new_res;
            }

            get_action(action_id) {
                const res = this.actions.find(v => v.id === action_id);
                if (res) return res;
                const new_res = Vue.reactive(new ActorAction(this.name_key, action_id));
                this.actions.push(new_res);
                return new_res;
            }
        }

        class Record {
            constructor(time_ms = 0) {
                const date = time_ms ? new Date(time_ms) : new Date();
                this.time_ms = date.getTime();
                this.last_record_at = 0;
                this.last_chart_at = 0;
                this.name = `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;
                this.actors = [];
                this.evt_time_over_ptr = 0;
                this.show_chart = false;
                this.dps_canvas = null;
                this.dmg_canvas = null;
                this.archived = false;

                this.damage = 0;
            }

            get_actor(idx, id, party_idx) {
                const res = this.actors.find(v => v.idx === idx);
                if (res) return res;
                if (!id) return null;
                const new_res = Vue.reactive(new Actor(this.time_ms, idx, id, party_idx));
                this.get_ex().new_chart_actor(new_res.display_name, new_res.color);
                this.actors.push(new_res);
                return new_res;
            }

            process_overtime(time_ms = 0, e = 60 * 1000) {
                time_ms = (time_ms || Date.now()) - e;
                const events = this.get_ex().events;
                let evt;
                while (evt = events[this.evt_time_over_ptr]) {
                    if (evt.time_ms > time_ms) break;
                    switch (evt.type) {
                        case "damage":
                            const {source, damage} = evt.data;
                            const [source_type, source_idx, source_id, source_party_idx, ..._] = source;
                            if (source_party_idx === -1) break;
                            const actor = this.get_actor(source_idx, source_id, source_party_idx);
                            actor.damage_in_minute -= damage;
                            break;
                    }
                    this.evt_time_over_ptr++;
                }
            }

            calc_damages(time_ms = 0) {
                time_ms = time_ms || Date.now();
                const evt_time = (this.last_record_at - this.time_ms) / 1000;
                const evt_time_in_minute = Math.min(evt_time, 60);
                const real_time = (time_ms - this.time_ms) / 1000;
                for (const actor of this.actors) {
                    actor.dps = Math.floor(actor.damage / real_time);
                    actor.dps_in_minute = Math.floor(actor.damage_in_minute / evt_time_in_minute);
                }
                this.show_chart = evt_time > 5;
                if (this.show_chart && this.dps_canvas && this.dmg_canvas && this.last_chart_at !== this.last_record_at) {
                    this.get_ex().update_chart(real_time, this);
                    this.last_chart_at = this.last_record_at;
                }
            }

            update(time_ms = 0) {
                if (this.archived) return;
                this.process_overtime(time_ms);
                this.calc_damages(time_ms);
            }

            redraw_chart() {
                this.get_ex().redraw_chart(this);
            }

            get_ex() {
                return RecordEx.get_instance(this.time_ms);
            }

            export_log() {
                const res = ''.concat(...this.get_ex().events.map(({time_ms, type, data}) => {
                    switch (type) {
                        case "damage":
                            const {source, target, damage, flags} = data;
                            const [source_type, source_idx, source_id, source_party_idx, ..._] = source;
                            const [target_type, target_idx, target_id, target_party_idx, ...__] = target;
                            const action_id = evt_action_id(data);
                            const date = new Date(time_ms);
                            return `${date.getFullYear()}/${date.getMonth()}/${date.getDay()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}|damage|` +
                                    `${source_type};${source_idx};${numberToHexStringWithZFill(source_id, 8)};${source_party_idx};${actor_name(source_id)}|` +
                                    `${target_type};${target_idx};${numberToHexStringWithZFill(target_id, 8)};${target_party_idx};${actor_name(target_id)}|` +
                                    `${action_id}|${action_name(source_id, action_id)}|${damage}|${flags}\n`;
                    }
                    return '';
                }))
                const bolb = new Blob([res], {type: 'text/plain'});
                if (window.navigator.msSaveOrOpenBlob) {
                    window.navigator.msSaveBlob(bolb, `${this.name}.txt`);
                } else {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(bolb);
                    a.download = `${this.name}.txt`;
                    a.click();
                }
            }

            destroy() {
                RecordEx.destroy_instance(this.time_ms);
            }
        }

        const App = Vue.createApp({
            setup: function () {
                const is_socket_connected = Vue.ref(false);
                const records = Vue.ref([]);
                const view_record_value = Vue.ref("");
                const actor_dialog = Vue.reactive({
                    visible: false,
                    actor: null,
                    page: 'targets',
                    action_chart: {
                        canvas: null,
                        selected: null,
                    },
                });
                const cfg = Vue.ref(JSON.parse(localStorage.getItem('act_ws_cfg') || "{}"));
                const screen = Vue.reactive({
                    width: window.innerWidth,
                    height: window.innerHeight,
                });
                const update_var = {
                    want_new: false,
                    period: 0,
                    last_frame: 0,
                }
                const export_log = (record) => record.export_log();

                const set_actor_dialog = (actor) => {
                    if (actor) {
                        actor_dialog.actor = actor;
                        actor_dialog.visible = true;
                    } else {
                        actor_dialog.visible = false;
                        actor_dialog.actor = null;
                        actor_dialog.action_chart.selected = null;
                        ActionDamageChart.instance?.destroy();
                        ActionDamageChart.instance = null;
                    }
                }

                const remove_record = (name) => {
                    const idx = records.value.findIndex(v => v.name === name);
                    if (idx >= 0) {
                        records.value[idx].destroy();
                        records.value.splice(idx, 1);
                    }
                }
                const archive_record = (record, time_ms = 0) => {
                    update_var.want_new = true;
                    record.update(time_ms);
                    record.redraw_chart();
                    record.is_archived = true;
                }

                const new_record = (time_ms = 0) => {
                    const _records = records.value;
                    if (_records.length > 0) archive_record(_records[_records.length - 1], time_ms);
                    const res = Vue.reactive(new Record(time_ms));
                    _records.push(res)
                    view_record_value.value = res.name;
                    update_var.want_new = false;
                    return res;
                }

                const get_latest_record = () => records.value.length === 0 ? new_record() : records.value[records.value.length - 1];


                const on_damage = (evt) => {
                    const {time_ms, data} = evt;
                    if (update_var.want_new) new_record(time_ms);
                    const {source, target, damage} = data;
                    const [source_type, source_idx, source_id, source_party_idx, ..._] = source;
                    const [target_type, target_idx, target_id, target_party_idx, ...__] = target;
                    if (target_id === 0x22a350f) return; // HARDCODE: 对欧根附加炸弹造成的伤害不进行记录
                    // TODO: 自伤类技能的过滤
                    const current_record = get_latest_record();
                    current_record.last_record_at = time_ms;
                    if (source_party_idx === -1) return;
                    current_record.get_ex().events.push(evt);
                    current_record.damage += damage;
                    const actor = current_record.get_actor(source_idx, source_id, source_party_idx);
                    actor.hit += 1;
                    actor.damage += damage;
                    actor.damage_in_minute += damage;
                    const target_actor = actor.get_target(target_idx, target_id, target_party_idx);
                    target_actor.damage += damage;
                    const action = actor.get_action(evt_action_id(data));
                    action.hit += 1;
                    action.damage += damage;
                    if (action.min === -1 || action.min > damage) action.min = damage;
                    if (action.max === -1 || action.max < damage) action.max = damage;
                    if (actor_dialog.action_chart.selected === action)
                        ActionDamageChart.instance?.put({x: (time_ms - current_record.time_ms) / 1000, y: damage});
                    if (log_cond.damage)
                        log(`${actor.display_name} cause ${damage} damage by ${action.display_name} to ${target_actor.name}`);
                }

                const evt_buffer = []

                const update = (period = 1000) => {
                    let evt;
                    while (evt = evt_buffer.shift()) {
                        if (log_cond.evt) log(evt);
                        if (!update_var.last_frame) update_var.last_frame = evt.time_ms;
                        while (evt.time_ms > update_var.last_frame + period) {
                            update_var.last_frame += period;
                            get_latest_record().update(update_var.last_frame);
                        }
                        switch (evt.type) {
                            case "enter_area":
                                archive_record(get_latest_record());
                                break;
                            case "damage":
                                on_damage(evt);
                                break;
                        }
                    }
                    const last_record = get_latest_record();
                    if (update_var.last_frame && Date.now() > last_record.last_record_at + period) while (last_record.last_record_at > update_var.last_frame) {
                        update_var.last_frame += period;
                        get_latest_record().update(update_var.last_frame);
                    }
                    get_latest_record().redraw_chart();
                }

                const create_socket = () => {
                    const socket_ = new WebSocket("ws://localhost:24399");
                    socket_.addEventListener("message", evt => evt_buffer.push(JSON.parse(evt.data)));
                    socket_.addEventListener("open", () => {
                        is_socket_connected.value = true;
                        socket = socket_;
                    });
                    socket_.addEventListener("close", () => {
                        is_socket_connected.value = false;
                        socket = null;
                        if (update_period > 0)
                            setTimeout(create_socket, update_period);
                    });
                    socket_.addEventListener("error", evt => {
                        console.error("Ws Error", evt);
                        is_socket_connected.value = false;
                        socket = null;
                    });
                }

                const init_cfg = () => {
                    const cfg_val = cfg.value;
                    const setdefault = (key, val) => {
                        if (!(key in cfg_val)) cfg_val[key] = val;
                    }
                    setdefault('chart', 'dps_min');
                    setdefault('keep_record', false);
                    cfg.value = cfg_val;
                }

                const handleBeforeUnloadStoreRecord = (e) => {
                    if (cfg.value.keep_record) {
                        const ex = get_latest_record().get_ex();
                        localStorage.setItem('latest_record_events', JSON.stringify({
                            key: ex.key,
                            events: ex.events.concat(evt_buffer),
                        }));
                    }
                }
                const handleWindowResize = () => {
                    screen.width = window.innerWidth;
                    screen.height = window.innerHeight;
                }
                var update_interval = null;
                Vue.onMounted(() => {
                    init_cfg();
                    if (cfg.value.keep_record) {
                        records.value = [];
                        try {
                            const str = localStorage.getItem('latest_record_events');
                            if (str) {
                                const {key, events} = JSON.parse(str);
                                new_record(key);
                                evt_buffer.push(...events);
                            }
                        } catch (e) {
                            err(e);
                            records.value = [];
                            RecordEx.instances = {};
                        }
                        want_new = !!records.value.length;
                        localStorage.removeItem('latest_record');
                    }
                    Vue.watch(cfg, (v) => localStorage.setItem('act_ws_cfg', JSON.stringify(v)), {deep: true});
                    Vue.watch(() => i18n.global.locale, i18nCfg.onLocaleChange)
                    Vue.watch(() => actor_dialog.action_chart.selected, (action) => {
                        if (action && actor_dialog.actor) {
                            let chart = ActionDamageChart.instance;
                            if (!chart) {
                                if (!actor_dialog.action_chart.canvas) return;
                                chart = ActionDamageChart.instance = new ActionDamageChart(actor_dialog.action_chart.canvas);
                            }
                            const record = records.value.find(v => v.time_ms === actor_dialog.actor.record_key);
                            if (!record) return err('record not found for ', actor_dialog.actor);
                            const datas = []

                            for (const {time_ms, type, data} of record.get_ex().events.reverse()) {
                                if (type !== 'damage') continue;
                                const {source, damage} = data;
                                if (source[1] !== actor_dialog.actor.idx) continue;
                                if (evt_action_id(data) !== action.id) continue;
                                datas.push({x: (time_ms - record.time_ms) / 1000, y: damage});
                                if (datas.length >= chart.max_display) break;
                            }
                            chart.set({label: action.display_name, datas: datas.reverse()});
                            chart.chart.update();
                        } else {
                            ActionDamageChart.instance?.clear();
                        }
                    })
                    create_socket();
                    update_interval = setInterval(update, 200);
                    window.addEventListener('beforeunload', handleBeforeUnloadStoreRecord);
                    window.addEventListener('resize', handleWindowResize);
                });

                Vue.onUnmounted(() => {
                    update_period = -1;
                    if (socket) socket.close();
                    handleBeforeUnloadStoreRecord();
                    clearInterval(update_interval);
                    window.removeEventListener('beforeunload', handleBeforeUnloadStoreRecord);
                    window.removeEventListener('resize', handleWindowResize);
                });

                return {
                    cfg,
                    screen,
                    view_record_value,
                    is_socket_connected,
                    records,
                    export_log,
                    fmtTime,
                    remove_record,
                    actor_dialog,
                    set_actor_dialog,
                    numberWithComma,
                }
            }
        })
        App.use(ElementPlus);
        App.use(i18n);
        for (const [key, component] of Object.entries(ElementPlusIconsVue)) App.component(key, component);
        App.mount('#app');
    }).catch(alert)


</script>
</html>
